### Разбор тестового задания на стажировку для QA-инженеров в Авито (весенний отбор 2024)
Тестовое состояло из двух заданий. 
В первом задании мы предлагали найти баги и определить их приоритеты на тестовой странице поисковой выдачи Авито. Во втором задании мы предлагали написать автотест.
___
### Задание 1. Поиск багов. 

**Вот на что мы обращали внимание при проверке этого задания:**

1. Количество найденных багов. Именно багов, Мы не обращали внимание, когда кандидат скатывается до придирок для пополнения их количества.  
2. Описание бага. Важно чтобы кандидаты умели правильно описывать баги, чтобы мы не пытались догадаться , что кандидат имел ввиду. При этом хорошо, если оно не избыточное.  
3. Сколько найдено критичных багов. Критичных багов в тестовом задании было не так много, поэтому важно было найти все критичные баги.  
4. Насколько точно были определены приоритеты в найденных багах. Это важный аспект при работе с багами как в тестовых заданиях так и в работе.  
5. Отдельный плюс ставили за аргументацию выставления приоритетов багов.

**Хотим поделиться советами о том, как лучше выполнять подобные задания:**

1. **Определите главную функциональность страницы**. Что может быть главной функциональностью на странице с поиском объявлений?  
    1. Поиск по тексту.  
    2. Работа фильтров.  
    3. Выдача объявлений.  
2. **Посмотрите на внешний вид**. Вам необходимо убедиться, что на странице нет багов, которые могут испортить репутацию компании.  
3. **Определите приоритеты**. Чтобы проверить себя, руководствуйтесь разделом priority/severity в ISTQB.  

___

### Задание 2. Автотесты. API или UI

В этом наборе мы хотели дать возможность стажерам проявить себя не только при написании UI e2e тестов, но и при написании API-автотестов, что также является важным навыком и может быть очень полезным в различных проектах. Поэтому было предложено два варианта задания.
UI-автотесты. Как будет организована работа с web-страницами? Какие проверки будут реализованы?
API-автотесты. Как ручки будут обрабатывать невалидные входные данные? Какой ответ уйдет пользователю с учетом разграничения доступа? Правильно ли ручки обрабатывают граничные значения?
Несмотря на очевидные различия в этих видах тестов, есть в заданиях и много общего. Помимо самих проверок, в автотестах мы обращали внимание на организацию и структуру проекта, прозрачную историю коммитов, чистоту кода и отсутствие дублирования кода, применение техник тест-дизайна, паттернов программирования и автоматизации тестирования.
Ниже посмотрим на некоторые моменты из заданий ребят, прошедших отбор в этом периоде. А с подробным текстом заданий можно ознакомиться по [ссылке](https://github.com/avito-tech/tech-internship/blob/main/Tech%20Internships/QA/QA-trainee-assignment-autmumn-2024/QA-trainee-assignment-autumn-2024.md#%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-2)

#### Структура проекта
Структура проекта, логика директорий и наименований файлов — это всё часть культуры работы с кодом.
Если взять самые красивые, понятные и стабильные автотесты и сложить их в папочку «new folder» с именами test_1, test_2 — они сразу станут непонятными и некрасивыми.
Примеры: 

* Иерархичная стурктура, понятные названия* 

![](QA-trainee-assignment-spring-2024/images/img_4.png)

* Плоская структура с безликими именами*

![](QA-trainee-assignment-spring-2024/images/img_5.png)

#### Инструкция 
Инструкция. Чем проще, тем лучше: склонировать, установить зависимости, запустить.
Примеры: 

*В меру подробная инструкция*

1. Склонируйте к себе репозиторий, в котором хранится проект тестового задания, через выполнение команды в терминале
    ```
    git clone https://github.com/Herzenswearme/AvitoTech_QA-trainee.git
    ```
    Или скачайте zip архив по [ссылке](https://github.com/Herzenswearme/AvitoTech_QA-trainee/archive/refs/heads/main.zip) и распакуйте его


2. Убедитесь, что на Вашем компьютере установлен Python. В командной строке/терминале выполните команду
    ```
    python -v
    ```  
    Если он не установлен, то установите с официального [сайта Python](https://www.python.org/downloads/), выбрав подходящую версию для Вашей операционной системы, и пройдите шаг сначала.  В процессе установки обязательно поставьте галочку в чекбоксе "Add python.exe to PATH". Иначе, у Вас не будет корректно отображаться версия Python

3. Через командную строку/терминал перейдите в корневую директорию проекта, выполнив команду
   ```
   cd /здесь укажите путь до директории с проектом
   ```

4. Установите необходимые зависимости из файла `requirements.txt`, выполнив команду  
   ```
   pip install -r requirements.txt
   ```
   если она не выполняется, то попробуйте
   ```
   pip3 install -r requirements.txt
   ```
5. После успешной установки зависимостей, установите необходимые бинарные файлы браузеров, выполнив команду
   ```
   playwright install
   ```
   
6. Наконец, запустите тесты, выполнив команду  
   ```
   pytest -v
   ```
> Очень приятная инструкция, написанная живым человеческим языком. От такой инструкции веет теплотой и заботой. Уже здесь чувствуется, что у кандидата отличные софт-скиллы!

*До жестокости подробная (и усложнённая) инструкция* 
1. Открыть PyCharm.
2. В верхнем меню навести курсором на “File”.
3. В выпадающем списке нажать на “New Project..”.
4. Поставить чек-бокс на “Create a main.py welcome script”.
5. Нажать кнопку “Create”.
6. Нажать кнопку “This Window”.
7. Вернуться в GitHub и скопировать код из файла “test.py”.
8. Вернуться в PyCharm и вставить скопированный код в созданный файл main.py.
9. Открыть терминал(В нижнем левом углу нажать на значок  квадрата внутри символы >_) . Откроется терминал.
10. Написать в терминале команду pip install pytest-playwright. Подождать, когда закончится загрузка.
11. Написать в терминале команду playwright install. Подождать, когда закончится загрузка.
12. Для получения скриншотов для счетчика воды нажать на зеленый треугольник находящийся рядом с функцией def test\_water(page: Page): . Нажать на Run.
13. Подождать, когда функция завершит работу.
14. Если возникли ошибки при запуске, то зайти в терминал и вставить команду pytest -k test\_water
15. Для получения скриншотов для счетчика CO2 нажать на зеленый треугольник находящийся рядом с функцией def test\_co2(page: Page): . Нажать на Run.
16. Подождать, когда функция завершит работу.
17. Если возникли ошибки при запуске, то зайти в терминал и вставить команду pytest -k test\_co2
18. Для получения скриншотов для счетчика энергии нажать на зеленый треугольник находящийся рядом с функцией def test\_energy(page: Page): . Нажать на Run.
19. Подождать, когда функция завершит работу.
20. Если возникли ошибки при запуске, то зайти в терминал и вставить команду pytest -k test\_ energy
21. Слева появится папка с названием “output”. В ней расположены полученные скриншоты. 

> Вместо первых 8 пунктов можно было просто написать «склонируйте репозиторий». Хотя даже это лишнее. 

#### Параметризация
Сила автотестов — в повторяемости. Вы берёте входные данные, описываете в коде действия с ними и свои ожидания от результата.
Если действия одни и те же, а меняются только входные данные — это нужно параметризировать! 

---
```python
    a = [1, 999, 1000, 1001, 9954, 9955, 10000, 10001, 10049, 10050, 99950, 100000, 100499, 100500, 999449, 999500,
          1000000, 1044000, 1045000, 999449000, 999500000, 1000000000]
    for i, elem in enumerate(a):
        page.goto("https://www.avito.ru/avito-care/eco-impact", wait_until="domcontentloaded")
```
> Однобуквенная переменная, хранящая все кейсы в одном списке — трудная для восприятия структура.

---
```python
@pytest.mark.parametrize('co2, energy, materials, pine_years, water, test_case', (
        (0, 0, 0, 0, 0, 'TK-1'),
        (999, 999, 999, 999, 999, 'TK-2'),
        (1000, 1000, 1000, 1000, 1000, 'TK-3'),
        (1500, 1500, 1500, 1500, 1500, 'TK-4'),
        (1000000, 1000000, 1000000, 1000000, 1000000, 'TK-5'),
        (1000000000000, 1000000000000, 1000000000000, 1000000000000, 1000000000000, 'TK-6'),
        (1000000000000000, 1000000000000000, 1000000000000000, 1000000000000000, 1000000000000000, 'TK-7'),
        (-1, -1, -1, -1, -1, 'TK-8'),
))
```
> Использована параметризация, кейсы объединены в классы эквивалентности, у кейсов есть имя.
> Что можно улучшить: здесь очевидно можно избавиться от дублирования чисел. 
---

```python
        replaceable_responses = [
            generate_response(co2=1, energy=50, water=999),  # ОР: co2 = 1 кг, energy = 50 кВт/ч, water = 999 л
            generate_response(co2=1000, energy=1000, water=1000),  # ОР: co2 = 1 т, energy = 1 МВт/ч, water = 1 м3
            generate_response(co2=1000000, energy=1000000, water=1000000),  # ОР: co2 = 1 тыс. т, energy = 1 тыс. МВт/ч, water = 1 тыс. м3
            generate_response(co2=1000000000, energy=1000000000, water=1000000000),  # ОР: co2 = 1 млн. т, energy = 1 млн. МВт/ч, water = 1 млн. м3
            generate_response(co2=1000000000000, energy=1000000000000, water=1000000000000),  # ОР: co2 = 1 млрд. т, energy = 1 млрд. МВт/ч, water = 1 млрд. м3
            generate_response(co2=1000000000000000, energy=1000000000000000, water=1000000000000000)  # ОР: co2 = 1 квдрлн. т, energy = 1 квдрлн. МВт/ч, water = 1 квдрлн. м3
        ]
```
> Использованы комментарии для хранения ожидаемого результата. Но не очень удачно — горизонтальный скролл — это плохо.
> Однако, почему-то в первом кейсе использованы разные значения 🤔
> Ещё никто не улучшил читаемость больших чисел используя встроенные в пайтон способы, например `1_000_000` или `10**9`

---
```go
// Граница конвертации в тонны
	{
		testName:    "Energy 998",
		description: "Класс [0:1000) шаг в границу ",
		energyValue: 998,
	},
	{
		testName:    "Energy 999",
		description: "Класс [0:1000) граничное значение и шаг за границу для класса [1000:1000000)",
		energyValue: 999,
	},
	{
		testName:    "Energy 1000",
		description: "Класс [0:1000) шаг за границу и граничное значение для класса [1000:1000000)",
		energyValue: 1000,
	},
	{
		testName:    "Energy 1001",
		description: "Шаг за границу для класса [1000:1000000)",
		energyValue: 1001,
	},
	{
		testName:    "Energy 550000",
		description: "Класс [1000:1000000) типичный представитель",
		energyValue: 550000,
	},
```
> Параметризация с помощью структуры позволяет максимально полно описать что и почему тестируется.

#### Тесткейсы
![](QA-trainee-assignment-spring-2024/images/img_7.png)
> Таблицу с узкими колонками и горизонтальным скроллом неудобно читать и понимать.

---
![](QA-trainee-assignment-spring-2024/images/img.png)
 
> 68 тест-кейсов начинаются с «1. С помощью Charles...». Можно упаковать в общие предусловия.   

#### Багрепорт
Чёткая структура, багрепорт — как карточка, которая помещается на один экран. Круто!

![](QA-trainee-assignment-spring-2024/images/img_6.png)

#### Работа с Git
![](QA-trainee-assignment-spring-2024/images/img_1.png)
> Коммит с названием "1" лучше переименовать так, чтобы было понятно, что внутри коммита. 

---
![](QA-trainee-assignment-spring-2024/images/img_2.png)
> Здесь вся работа над тестами уложилась в час времени. Весьма похвальная скорость!

---
![](QA-trainee-assignment-spring-2024/images/img_3.png)
> .DS_Store — этот файл не несёт информации о проекте или исходном коде, лучше убрать

**Общий вывод:** 
1. Документируйте историю изменений понятными названиями комитов
2. Следите за тем, чтобы репозиторий не засорялся
3. Подумайте о коллеге, который будет читать ваши файлы. Сделайте их понятными и удобными:)
